.. _user_hydro:

Array hydrodynamic module
-------------------------

Introduction
^^^^^^^^^^^^

The scope of the Hydrodynamics module is the identification of an array
configuration that maximise the annual energy production (AEP) of the array,
while holding the average q-factor of the array above a user specified
threshold. The q-factor is an energy losses index, definable as the
modification of the absorbed energy due to the hydrodynamic interaction between
bodies. It is calculated as the AEP of the array (:math:`AEP_{array}`) over the
AEP of the same array without considering the interaction.

.. math::

   q = \frac{AEP_{array}}{AEP_{WEC} \times N_{WEC}}
   
where :math:`AEP_{WEC}` is the energy production of the WEC at the same
location, but without interaction with other devices and :math:`N_{WEC}` is the
number of devices installed in the array.

The package solves the hydrodynamic interaction between the devices in the array
and, based on the solution of the hydrodynamic problem, the energy extracted by
each device. The latter is in turn used to estimate the q-factor for the array.

The AEP is used as the cost function of the optimisation loop that needs to be
maximised. The optimisation parameter space is defined by the array parameters,
such as device inter-distance, rows and columns angles, etc.

The optimum search is constrained by the following variables:

 * no-go areas
 * minimum distance between devices
 * maximum number of devices
 * q-factor.

No-go area identifies a zone of the lease area where the installation of the
device is not possible, in relation to several reasons such as: nfeasible water
detph, environmental motivations, etc. The no-go areas are specified by the
user, if known a priori, as well as internally calculated based on the site and
machine specification.

The minimum distance between devices identifies the minimum allowed distance
between installed devices. This distance is constrained by physical limitation,
such as vessel operating, but also by theoretical limitation of the numerical
model. For example, for an array of WEC, the minimum distance between devices
is obtained by the diameter of the inscribing cylinder.

The maximum number of device is used to obtain an array that fits the target
array size specified by the user.


Architecture
^^^^^^^^^^^^

The core of the package is divided into two sub-packages, namely tidal and wave.

The tidal sub-package solves the hydrodynamic interaction between turbines using
a parametrised look-up table to describe the wake shape and solving the wake
interaction based on the semi-empirical models inherited from the wind sector.
The wakes are placed in the array area based on the estimation of the
streamlines evaluated using Lagrangian drifters at the turbines locations. The
wake shape look-up table is populated from CFD runs.

The wave sub-package solves the hydrodynamic interaction within the array using
the so-called direct matrix method. The method uses the cylindrical coordinate
description of the wave filed generated by the presence of the moving device,
and maps it to the global array coordinate system. The solution of the
hydrodynamic problem in the cylindrical coordinate system is obtained by
solving the Laplace equation in the fluid domain, using a boundary element
method solver.

For a detailed description of the mathematical formulation of the hydrodynamics
algorithms see (Silva, et al., 2015) 

At a high level the hydrodynamics module is divided into two blocks: 

 * main routine where the pre-processing is carried out 
 * optimisation routine where the actual array optimisation is performed. 

The top-level view of the code is simplified in 
:numref:`fig-hydrodynamics-user`. The figure shows two main and separated 
blocks: the hydrodynamic module and the wec-standalone module. 

The wec-standalone module is a separated module used to generate the input
requried by the hydrodynamic module in terms of single machine hydrodynamic for
the case of WEC.

The wec-module is not part of the following description.

.. _fig-hydrodynamics-user:

.. figure:: /images/user/hydrodynamics.png

   Hydrodynamic model top level view.


The main routine collects the inputs and evaluates the following quantities:

 * Assess the No-Go zones from the site bathymetry and installation
   constraints specified by the users.
 * Active Area defined as the lease area subtracted from the no-go areas. The
   subtraction should be intended as a boolean operation.
 * Load the WEC hydrodynamic module genrated by the wec-standalone module.

Additionally, the routine generates three objects; a Hydro, an Array and a
Device class object:

 * The Hydro class object collects the metocean conditions that describe the
   features of the site., i.e bathymetry, sea state description, etc.
 * The Array class object is used to generate the grid layout given the array
   type and the parameters value, and to identify which devices are inside the
   active area. A check on the minimum distance constraint is performed too.
 * The Device object collect all the information of the single device and
   generates all the quantities needed to solve the hydrodynamic interaction
   between devices.

The optimisation routine calls either the tidal or wave submodule, for the
resolution of the array interaction problem, given the required inputs.

Functional specifications
^^^^^^^^^^^^^^^^^^^^^^^^^

Inputs
''''''

The hydrodynamic module requires slightly different inputs for arrays of wave
and tidal converters as shown in the figure below and detailed in
:numref:`fig-hydro-inputs`.


.. image:: /images/user/hydro_tidalwave.png


The cyan box represent the common inputs, the purple box the tidal specific
inputs and the green box the wave specific inputs. The Red indicator means
“missing input”, the Blue “optional input” and the Green “satisfied input”. 

.. image:: /images/user/hydro_inputs1.png

.. _fig-hydro-inputs:

.. figure:: /images/user/hydro_inputs2.png

   List of inputs for Hydrodynamic module


Execution
'''''''''

Once a new project is created the first operation to perform is the selection of
the device type. :numref:`fig-hydro-device` show the four possible choice, the
selection is concluded by pressing the Ok button.

.. _fig-hydro-device:

.. figure:: /images/user/hydro_device.png

   Selection of the device type in the new project input


After the device type is selected, it is possible to add the hydrodynamic module
to the list of module to run. 

.. _fig-hydro-module:

.. figure:: /images/user/hydro_module.png

   Module selection in the project window.


To perform the operation:

 * click the Module Selection icon in the Tool bar (green text and arrow in
   :numref:`fig-hydro-module`). This will open the Add Module widget.
 * Select the Hydrodynamic module form the list of available modules, and
   click the Add button (purple text and arrow in Figure 5 3). 
 * confirm the selection by clicking the Ok button (cyan text and arrow in
   :numref:`fig-hydro-module`). 

Prior to perform the last step check if the Hydrodynamic module has been added
to the Selected list, otherwise repeat the second step.

After the dataflow has been checked, the user will now be able to add the
relevant input for the case to be solved (:numref:`fig-hydro-data`). It is
important to note that the data can be inserted manually or using a precompiled
database (SQL format).

Once all the compulsory data has been inserted in the GUI, it is possible to run
the Module by clicking the Run button in the tool bar.


.. _fig-hydro-data:

.. figure:: /images/user/hydro_data.png

   Data Input phase


Outputs
'''''''

 As introduced previously the Hydrodynamic module will return an output
 object at the end of the run with the following attributes (use the GUI
 visualise manager to plot the relevant data):
   
 * AEP_array (float)[Wh]: annual energy production of the whole array
 * power_prod_perD_perS (numpy.ndarray)[W]: average power production of each
   device within the array for each sea state
 * AEP_perD (numpy.ndarray)[Wh]: annual energy production of each device
   within the array
 * power_prod_perD (numpy.ndarray)[W]: average power production of each
   device within the array
 * Device_Positon (numpy.ndarray)[m]: UTM coordinates of each device in the
   array. NOTE: the UTM coordinates do not consider different UTM zones. The
   maping in the real UTM coordinates is done at a higher level.
 * Nbodies (float)[]: number of devices in the array
 * Resource_reduction (float)[]: ratio between absorbed and incoming energy.
 * Device_Model (dictionary)[WAVE ONLY]: Simplified model of the wave energy
   converter. The dictionary keys are:

   * wave_fr (numpy.ndarray)[Hz]: wave frequencies used to discretise the
     frequency space
   * wave_dir (numpy.ndarray)[deg]: wave directions used to discretise the
     directional space
   * mode_def (list)[]: description of the degree of freedom of the system
     in agreement with the definition used in WAMIT taking in consideration
     only translational degrees of freedom
   * f_ex (numpy.ndarray)[]: excitation force as a function of frequency,
     direction and total degree of freedoms, normalised by the wave height. The
     degree of freedoms need are only the three translation defined in the mode
     keys.

 * q_perD (numpy.ndarray)[]: q-factor for each device, calculated as energy
   produced by the device within the array over the energy produced by the
   device without interaction
 * q_array (float)[]: q-factor for the array, calculated as energy produced
   by the array over the energy produced by the device without interaction
   times the number of devices.
 * TI (float)[TIDAL ONLY]: turbulence intensity within the array
 * power_matrix_machine (numpy.ndarray) [WAVE ONLY]: power matrix of the
   single WEC.
 * main_direction (numpy.ndarray): Easing and Northing coordinate of the main
   direction vector
