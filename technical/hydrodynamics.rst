.. _tech_hydro:

Hydrodynamics Module
--------------------

Requirements
^^^^^^^^^^^^

User Requirements
'''''''''''''''''

The scope of the Hydrodynamics module is the identification of an array
configuration that maximizes the AEP of the array, while holding the average
q-factor of the array above a user specified threshold. The q-factor is an
energy losses index, definable as the modification of the absorbed energy due
to the hydrodynamic interaction between bodies. It is calculated as the AEP of
the array over the AEP of the same array without considering the interaction.

The package solves the hydrodynamic interaction between OEC devices in the array
and, based on the solution of the hydrodynamic problem, the energy extracted by
each device. The latter is in turn used to estimate the q-factor for the array.

The AEP is used as the convergence criterion within the optimization loop. The
optimization parameter space is defined by the array parameters, such as device
inter-distance, rows and columns angles, etc. The parameter space is continuous
and real-valued.

The optimum search is constrained by the following variables: the no-go areas,
the minimum distance between devices, the maximum number of devices and the
q-factor.



Software Design Requirements
''''''''''''''''''''''''''''

The core of the package is divided into two sub-packages, namely tidal and wave.
This subdivision is driven by the different way of solving the hydrodynamic
interaction.

The tidal sub-package solves the hydrodynamic interaction between
turbines using a parametrized look-up table to describe the wake shape and
solving the wake interaction based on the semi-empirical models inherited from
the wind sector. The wakes are placed in the array area based on the estimation
of the streamlines evaluated using Lagrangian drifters at the turbines
locations. The wake shape look-up table is populated from CFD runs.

The wav esub-package solves the hydrodynamic interaction within the array using
the so-called direct matrix method. The method uses the cylindrical coordinate
description of the wave field generated by the presence of the moving device,
and maps it to the global array coordinate system. The solution of the
hydrodynamic problem in the cylindrical coordinate system is obtained by
solving the Laplace equation in the fluid domain, using a boundary element
method solvers.

For a detailed description of the mathematical formulation of
the hydrodynamics algorithms see (Silva, et al., 2015).

Architecture
^^^^^^^^^^^^

At a high level the Hydrodynamics module is divided into two blocks: the main
routine where the pre-processing is carried out and an optimization routine
where the actual array optimization is performed. The top level view of the
code is simplified in :numref:`fig-hydrodynamics-tech`.

.. _fig-hydrodynamics-tech:

.. figure:: /images/technical/hydrodynamics.png

   Hydrodynamic model top level view.

The main routine collects the inputs and evaluates the following quantities:

 * The Active Area is defined as the no-go areas subtracted from the lease
   area
 * WEC hydrodynamic (only for wave energy converters) evaluates the
   hydrodynamic properties of the device in the local cylindrical coordinate
   system
 * WEC fitting (only for wave energy converters) tunes the numerical model
   to the user provided power performance of the device. It corresponds to the
   green box “single body performance fit” in :numref:`fig-hydrodynamics-tech`

Additionally, the routine requires two objects; a Hydro and an Array class
object:

 * The Hydro class object collects the metocean conditions that describe the
   features of the site, i.e. bathymetry, sea state description, etc.
 * The Array class object is used to generate the grid layout given the array
   type and the parameters value, and to identify which devices are inside the
   active area. A check on the minimum distance constraint is performed too 

The optimization routine calls either the tidal or wave submodule, for the
resolution of the array interaction problem, given the required inputs.



Modules and functions description
'''''''''''''''''''''''''''''''''

The detailed description of the programmatic structure of the Hydrodynamic
module is given hereafter; a graphical representation is given in the Unified
Modelling Language (UML) diagram presented in :numref:`fig-hydrodynamics-uml`.

.. _fig-hydrodynamics-uml:

.. figure:: /images/technical/hydrodynamics_uml.png

   UML diagram of the Hydrodynamic model.

**WP2input**:

The WP2input class is composed of two further classes, WP2_SiteData and
WP2_MachineData.

These classes contain the features of the development site and the actual
machine, respectively. Their role is passive since they are used as structured
data containers. The WP2_SiteData and the WP2_MachineData objects will be
initialised independently and so a line could be drawn between those objects
and WP2input (see :numref:`fig-hydrodynamics-uml`) illustrating the starting
point for the WP2.

On the contrary, a WP2input object will perform a series of tasks at the
initialisation.

 a. Check if the inputs conformed to the input requirements. If step (a)
    returns 0, i.e. inputs are correct, then:
 b. Map the angles into the hydrodynamic model format. The wave metocean
    conditions are given with angles defined in the reference system: South –
    West, while for the sake of simplicity the

Hydrodynamics module uses the convention East – North. The conversion is made at
the input level in order to avoid any confusion later in the process

 c. Identify the main angle, which is used for the array orientation. This will
    define the rotation matrix around the vertical axis. The main angle is
    extracted from the MainDirection, which is in turn given by the user in form
    of Easting-Northing components, or calculated from the sea state with the
    highest probability of occurrence. For the wave case the probability of
    occurrence is ranked applying the summation over the wave height and wave
    period axis
 d. Identify the polygons where the devices cannot be installed due to
    installation constraints dictated by the water depth. The method first checks
    for two trivial solutions, such as no feasible installation points and all
    feasible installation points. If none of the trivial solutions are present,
    the algorithm will:

     1. Identify the feasible and unfeasible installation points in the given
        bathymetry
     2. Cluster the unfeasible installation points using a density based method
     3. Identify the bounding polygons for each cluster (no-go area)
     4. Test if the polygon has some feasible point inside, and if that is the
        case identify the bounding polygon of the feasible area inside the unfeasible
        area

The generated WP2input object is then using to create a WP2 object at the
instantiation using a composition scheme.


**WP2**:

The WP2 class is the main controller class of the hydrodynamic model. It
initializes the Hydro class as well as the Array class (aggregation), which are
used all the way through the output generation. For the case of an array of
WECs, the WEC class is also instantiated. The WEC class is used to assess the
hydrodynamic features of a single WEC, which define the base for the solution
of the array interaction problem. Within the optimisationLoop method, the WP2
class conditionally instantiates a search optimum object that encapsulates the
optimization algorithm or generates a solution for the given array layout. The
type of array grid specified by the user leads the decision. This option gives
the user the freedom to specify an array layout or let the software decides the
best one.

At the completion of the work the WP2 class returns a WP2output object.


**Hydro_pkg**:

The Hydro_pkg class collects the information about the sea states of the site,
their probability of occurrence as well as the bathymetry and the sea surface
height at the given grid points.

The class can be considered to have an entity stereotype since it is used as a
structured data container.


**Array_pkg**:

The Array_pkg class collects the information of the active area, the main
orientation angle, and the minimum allowable distance between devices. The
active area is built from a Boolean intersection between the Lease Area and the
no-go areas.

An object is used in the optimization call, to generate an array layout, to
check on the feasibility of the given layout and to mute all devices that do
not belong to the Active Area.

The generation of the array layouts is based on the input grid structure type;
possible alternatives are:

 * Rectangular grid: perpendicular angle between rows and columns, and
   variable rows and columns distances
 * Staggered grid: equal distance and angle between rows and columns; the
   angle can vary in the range 0-90 degrees
 * Full grid: variable rows and columns distance and variable rows and column
   angles

Prior to the evaluation of the array interaction the array layout is verified
against the minimum distance parameter, in order to avoid violation of that
constraint. For the above-mentioned grids the check is performed on a single
cell of the grid, while for a user given array layout, the check is performed
sequentially for every point.

Lastly, each grid vertex is tagged with a Boolean value based on its position
with respect to the Active Area. Due to the irregularity of the Active Area,
the process is performed sequentially for each grid vertex.


**WEC**:

The WEC class is only instantiated for the case of an array of WECs and is used
to load and manage the numerical model of the isolated Wave Energy.


**search_optimum**:

The main objective of the search_optimum class is to generate the “best” array
layout given the specification of the deployment site and the single machine
properties.

“Best” is defined in agreement with the cost function built into the class,
which is targeted to maximize the AEP of the array, given some constraints of
the feasible solutions, such as the q-factor, the minimum distance between
devices or the maximum number of devices.

The search_optimum class uses (as a default option) a heuristic optimization
approach, of the Evolutionary Strat- egy type, to identify the array layout
that maximises the given cost function.

The parameter space order depends on the type of grid layout specified;
therefore a mapping rule between full and reduced order spaces is generated.
Then, the reduced parameter space is scaled so that the range of values is the
same regardless of the parameter.

The search algorithm is based on the concept of natural genetic evolution, where
the actual population holds the genes of the previous winner elements, and
additional randomness is brought by introducing random seeds in the generation
process. This is achieved by searching the optimum in the region defined by the
mean value plus and minus three standard deviations of the current population.
The mean and the standard deviation are weighted so that the best specimens
have more weight than the rest.

Each element of the population represents a different array layout, which
hydrodynamic interaction needs to be solved. The search_optimum class
instantiates either a CallTidal (in the tidal case) or a MultiBody (in the wave
case) object. The objects use the information of the array layout stored in the
Array object and the features of the single device to generate an array of
devices and solve their interaction.

For a more detailed description of the optimization algorithm the reader is
referred to (Silva, et al., 2015).


**CallTidal**:

The CallTidal class is an interface class used to query the wp2_tidal function,
given the device position, the machine specification and the site
specification. Superimposing the site velocity field with the single machine
one solves the hydrodynamic interaction. The single machine velocity field is
based on a parameterized wake database (distributed along with the Hydrodynamic
module), and the wake is located in the global coordinate system based on the
device position and the calculated streamline. The wp2_tidal method
instantiates an Array, a Hydro, a WakeInteraction, an ArrayYeld and a
HydroImpact object, which solve the interaction problem.


**Array**:

The Array class contains the information about the spatial distribution and the
hub velocity of the devices in the array and calculates the shape of the
streamlines for each device based on the velocity field of the area. The class
aggregates a number of streamline objects, one for each device, used to
calculate the streamline shape from the device position.


**Stramlines**:

The Streamlines class is used to calculate the streamline shape, giving the
velocity field of the area and the initial position. The algorithm uses a
Lagrangian drifter approach to evaluate the streamline shape.


**Hydro**:

The Hydro class contains the features of the site, such as velocity field,
bathymetry and geophysical information of the seabed.

The Hydro class has an entity stereotype since it is used primarily as a
structured container for the site data. WAKEINTERACTION:

The WakeInteraction class encapsulates the main algorithm to assess the
hydrodynamic interaction in the array. It uses the Wake and the WakeShape
classes to store and to map the single machine shape into the global ve- locity
field of the area. The resultant velocity field is obtained through an
iterative process, which involves the superimposition of the wakes and the
recalculation of the wake shapes for the new velocity field.


**Wake**:

The Wake class stores the 2D map of the velocity field around the machine, for
the given input conditions. The Wake queries a precompiled database with the
following entry points: thrust coefficients, turbulence intensity, yaw angle
and blockage ratio. The query is handled by FORTRAN code which is precompiled
as a Python extension module.


**WakeShape**:

The WakeShape class calculates the wake shape in the global coordinate system,
given a Wake object, the machine features and the streamlines previously
calculated.


**ArrayYeld**:
 
The ArrayYeld class is instantiated after the solution of the array interaction
and is used to calculate the power performance of each machine, given the
machine features and the hub velocity. It also assesses the dissipated mass
flow rate through the machine.


**HydroImpact**:

The HydroImpact class is instantiated after the solution of the array
interaction and the calculation of the array yield. It uses the dissipated mass
flow rate through the machine to assess the modification of the velocity field
induced by the array. This parameter is used to assess the environmental impact
of the array.


**Multibody**:

The Multibody class is the wave counterpart of the CallTidal object. It is used
to build an array of WECs and to solve the hydrodynamic interaction within the
array.

The generation of the array of WECs is based on the array layout coordinates and
on the single machine features, which are stored in the WEC object. The WEC
object is a prerequisite of the Multibody and is generated by the WP2 object in
the pre-processing phase. The Multibody class generates a numerical model of
the array using the direct matrix method, and evaluates the energy production
of the array based on the site features; in particular the definition of the
sea states and their probability of occurrence are used in this step.

During the energy assessment the Multibody class generates an instance of the
Wave_spec class.


**Wave_spec**:

The Wave_spec class is used to generate a parameterised wave energy distribution
over the spectrum of frequency and directions. It supports all the commonly
used types of frequency spectral models, such as the JONSWAP and
Pierson-Moskowitz (PM) spectra.


**WP2output**:

The WP2 class issues the WP2output object after the search of the “best” array
configuration is completed. The class has an entity stereotype.


Functional Specification
^^^^^^^^^^^^^^^^^^^^^^^^

Inputs
''''''

In order to use the Hydrodynamics module the first step is the generation of
WP2_SiteData and WP2_MachineData objects, which contains all the information
needed by the module to run.

The WP2_SiteData object has a series of ten inputs listed hereafter:

 * LeaseArea (numpy.ndarray) [m]: the area where the machines can be installed
 * NogoAreas (list) [m]: the area where the machines can NOT be installed
   within the “LeaseArea”
 * MetoceanConditions (dict): sea state definitions: the format is strictly
   related to the machine type (wave or tidal)
 * VelocityShear (numpy.ndarray) [-]: the power law exponent to be used in
   the definition of the vertical velocity profile
 * Main_Direction (numpy.ndarray, optional) [m]: the main direction of the
   array. The array will be aligned with this direction and the optimization
   parameter space will be defined around it. If a None value is passed, the
   model evaluates the main direction from the probability of occurrence of the
   different sea states
 * Bathymetry (numpy.ndarray) [m]: the seabed profile of the lease area, the
   datum is not important but it needs to be in agreement with the SSH
   parameter specified in the MetoceanConditions parameter
 * Geophysics (numpy.ndarray): the Manning number of the area, specified at
   each grid point. The value is used along with the VelocityShear to assess
   the vertical velocity profile.
 * BR (float) [-]: the horizontal blockage ratio, the ratio between the lease
   area and the channel area. A BR of 1 identifies a closed boundary lease
   area, while a BR of 0 identifies an open water scenario
 * electrical_connection_point (numpy.ndarray) [m]: UTM coordinates of the
   electrical connection point at the shore line, expressed as
   [X(Northing),Y(Easting)].
 * boundary_padding (float, optional) [m]: Padding added to inside of the
   lease area in which devices may not be placed

Similarly the WP2_MachineData object contains a list of nineteen inputs, of
which eight are optional, listed hereafter:

 * Type (str) [-]: either “wave” or “tidal”. The variable will trigger the
   different routines in the model
 * lCS (numpy.ndarray) [m]: position of the local representative point of the
   machine in the 3D space. For a wave case it is the position of the device
   centre of gravity seen from the mesh coordinate system. For a tidal case
   only the third (vertictal) coordinate is used to identify the position of
   the hub from the reference point. For a floating machine the reference point
   is the sea surface elevation, while for a bottom fixed machine it is the
   seabed
 * Clen (numpy.ndarray) [m]: (used only for a tidal case) the rotor diameter
   and the distance from the centre line. If the distance from the centre line
   is bigger than zero, a double rotor machine will be considered
 * YawAngle (float) [rad]: the yawing angle span of the machine, which
   describes the self-orienting capability of the device
 * Float_flag (bool): whether the machine is bottom fixed or floating
 * InstallDepth (list) [m]: the water depth range where the machine can be
   installed. All the points in the lease area which are not contained within
   the given range are grouped into nogo areas
 * MinDist (tuple) [m]: the minimum distance between devices in the array.
   For the wave case, the minimum distance is given by the circle that
   inscribed the machine, and this condition is enforced if the user specifies
   a smaller distance
 * OpThreshold (float) [-]: is the minimum q-factor allowable. The input is
   used during the optimum search to identify the maximum accepted value of the
   hydrodynamic losses. Any array layout that generates a q-factor smaller than
   the OpThreshold will be disregarded
 * UserArray (dict): identify the type of array layout to be evaluated, based
   on the Option parameter. If option 1 is chosen, one of the specified array
   layouts will be optimised. Possible choices are ‘Rectangular’, ‘Staggered’
   and ‘Full’. If option 2 is selected, the given array layout, specified in
   the value variable, is solved without optimisation. If option 3 is selected
   then the given array layout is optimised based on a simple homogeneous
   compression/expansion
 * RatedPowerArray (float) [W]: the target rated power of the array. This is
   used to bound the optimisation search
 * RatedPowerDevice (float) [W]: the rated power of the machine
 * wave_data_folder (string, optional): path name of the hydrodynamic results
   generate by the wave external module
 * tidal_power_curve (numpy.ndarray, optional)[W]: Power curve function of
   the stream velocity
 * tidal_trust_curve (numpy.ndarray, optional)[Nm]: Trust curve function of
   the stream velocity
 * tidal_velocity_curve (numpy.ndarray, optional)[m/s]: Vector containing the
   stream velocity
 * tidal_cutinout (numpy.ndarray, optional): contain the cut_in and cut_out
   velocity of the turbine.  Outside the cut IN/OUT velocity range the machine
   will not produce. The generator is shut down, but the machine will still
   interact with the others.
 * tidal_bidirectional (bool, optional): bidirectional working principle of
   the turbine
 * tidal_data_folder (string, optional): Path to tidal device CFD data files
 * UserOutputTable (dict, optional): dictionary of dictionaries where all the
   array layouts inputed and analysed by the user are collected. Using this
   option the internal WP2 calculation is skipped, and the optimisaton is
   performed in the given data. The dictionaies keys are the arguments of the
   WP2 Output class.


Execution
'''''''''

In the following, the sequence of commands to run the WP2 is given::

   >>> i = WP2input(Machine, Site)
   >>> WPobj = WP2(i)
   >>> Out = WPobj.optimisationLoop()

Machine is an instance of WP2_MachineData and Site is an instance of
WP2_SiteData, both must be initialized before WP2 can take place.

The variable Out is an instance of the class WP2output, with attributes the ones
listed in the previous section.



Outputs
'''''''


As introduced previously the Hydrodynamic module will return an output object at
the end of the run with the following attributes:

 * AEP_array (float)[Wh]: annual energy production of the whole array
 * power_prod_perD_perS (numpy.ndarray)[W]: average power production of each
   device within the array for each sea state
 * AEP_perD (numpy.ndarray)[Wh]: annual energy production of each device
   within the array
 * power_prod_perD (numpy.ndarray)[W]: average power production of each
   device within the array
 * Device_Positon (numpy.ndarray)[m]: UTM coordinates of each device in the
   array. NOTE: the UTM coordinates do not consider different UTM zones. The
   maping in the real UTM coordinates is done at a higher level.
 * Nbodies (float)[]: number of devices in the array
 * Resource_reduction (float)[]: ratio between absorbed and incoming energy.
 * Device_Model (dictionary)[WAVE ONLY]: Simplified model of the wave energy
   converter. The dictionary keys are:

   * wave_fr (numpy.ndarray)[Hz]: wave frequencies used to discretise the
     frequency space
   * wave_dir (numpy.ndarray)[deg]: wave directions used to discretise the
     directional space
   * mode_def (list)[]: description of the degree of freedom of the system
     in agreement with the definition used in WAMIT taking in consideration
     only translational degrees of freedom
   * f_ex (numpy.ndarray)[]: excitation force as a function of frequency,
     direction and total degree of freedoms, normalised by the wave height. The
     degree of freedoms need are only the three translation defined in the mode
     keys.

 * q_perD (numpy.ndarray)[]: q-factor for each device, calculated as energy
   produced by the device within the array over the energy produced by the
   device without interaction
 * q_array (float)[]: q-factor for the array, calculated as energy produced
   by the array over the energy produced by the device without interaction
   times the number of devices.
 * TI (float)[TIDAL ONLY]: turbulence intensity within the array
 * power_matrix_machine (numpy.ndarray) [WAVE ONLY]: power matrix of the
   single WEC.
 * main_direction (numpy.ndarray): Easing and Northing coordinate of the main
   direction vector.

Independently from the type of machine or simulation selected, the results
summarise the array layout and the power/energy performance of each machine. In
the following figures the results of the optimisation routine are illustrated.

:numref:`fig-array-layout` shows the resultant array layout along with much
other information. The results are generated for a WEC array, composed of
heaving cylinders. The waves are travelling from West to East.

The red lines identify the lease area polygon, and the blue shaded areas
identify the nogo areas specified by the user. As mentioned previously the
active area is the Boolean difference between the two areas.

The installed machines are represented by blue dots and tagged with the
corresponding ID number. The grey crosses represent grid points that are not
inside the active area. The Array_pkg object generates those points, but they
are not considered in the array interaction.

The arrow identifies the main direction, which corresponds to the wave direction
for this case; in fact the main direction input has been set to None, in which
case the software will calculate the orientation.

:numref:`fig-mean-AEP` represents the AEP per each device installed in the
array. On the x-axis the device ID is given to define relation between the
array layout and productivity in the array.

The first two rows of devices face a clean energy source, where the wave energy
content has been only slightly modified. This results in a higher energy
production for the first 11 devices. On the other hand, the rest of the devices
receive reduced energy content and their productivity tends to be lower.

It is important to bear in mind that the WECs are not only shadowing the
“down-wave” devices, therefore it can be possible to have devices in the centre
of the array that benefit from the energy radiated from the circumscribing
devices.

As shown in :numref:`fig-q-factor`, the q-factors of the different machines are
not monotonically decreasing in the Easting direction, as one could expect from
a shadowing model. The figure presents the q-factor for each device as an
additional vertical axis superimposed on the array layout plot presented in
:numref:`fig-array-layout`.

In simple words, the second rows of devices are taking advantage of a clean
energy source that has been boosted by the waves radiated by the first row of
devices. On the contrary, the rear rows of devices receive a scattered wave
field, which reduced their hydrodynamic efficiency if compared with the
isolated case.


.. _fig-array-layout:

.. figure:: /images/technical/array_layout.png

   Array layout. Installed machines (blue dots), unfeasible installation points (grey crosses), lease area (read polygon), user given nogo areas (blue area), main direction (blue arrow).


.. _fig-mean-AEP:

.. figure:: /images/technical/mean_AEP.png

   Mean AEP for each device expressed in kWh.


.. _fig-q-factor:

.. figure:: /images/technical/q_factor.png

   q-factor variation in the array.

   
*References* 

 * Silva, M., Raventos, A., Teillant, B., Ferri, F., Roc, T., Minns, N., et al. (2015). Deliverable 2.4: Algorithms providing effects of array changes on economics. WaveEC, AAU, ITP, SNL, FEM. Lisbon: EU - Commision.

   